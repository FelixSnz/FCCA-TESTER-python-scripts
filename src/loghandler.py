from batch import Batch
import json
import configparser
config = configparser.ConfigParser()
config.read('config\settings.ini')
log_info_json_path = config["Paths"]['LogInfoJson']
log_master_path = config["Paths"]['LogMaster']

class Log():
    """
    The class "Log" where a log is the file generated by FCCA TESTER.

    With that being said, this class defines a handler for a log file generated by 
    the FCCA TESTER
    """
    def __init__(self, log_path:str) -> None:
        self.path = log_path
        
        with open(log_info_json_path) as log_info_json:
            self.info = json.load(log_info_json)  
        if log_path != log_master_path:
            print("this is the log path: ", log_path)
            self.serial = log_path.split("_")[1].upper()
            self.date = log_path.split("_")[3].replace("-", "/")
            self.time = log_path.split("_")[5].split(".")[0]
            self.last_batch_name = "LED TEST"
            self.temp_batch = None
            self.status = None
            
    

    def get_failstring(self) -> str:
        """
        reads and searches for a fail, and when finds a fail in the logfile,
        extracts the needed information of the fail to store it in KEMX traz system 
        and returns the failstring
        fail string format: |ftestres=0,test_name,test_measurement,HighLimit,LowLimit,ExpectedValue,units,logic_operator
        """
        with open(self.path) as log_file:
            lines = log_file.readlines()
            passed_lines = []
            for line in lines:
                passed_lines.append(line)
                if 'FAIL' in line:
                    test_info = self.get_test_info(passed_lines, readable=True)
                    line_info = self.get_result_info(line)
                    measurement = line_info["measurement"]
                    high_limit = line_info["high limit"]
                    low_limit = line_info["low limit"]
                    nominal = line_info["nominal"]
                    units = self.temp_batch.temp_test["units"]
                    
                    return "|ftestres={0},{1},{2},{3},{4},{5},{6},{7}".format(0, test_info, measurement, high_limit, low_limit, nominal, units, "<>")
        return None

    

    def get_test_info(self, read_lines:list, readable=False) -> dict:
        """
        this function will read in reverse the given read_lines and exctract
        diferent layers of information (number of layers depending on the batch information)
        where all the layers are described as follows:
        batch name: the name of the group of tests
        test_name: name of the fail test
        subtest name: if the batch has subtests, the sub test name will be added
        test set values: if the batch has sets, the sub test name will be added
        this inf is returned as a python dictionary
        """
        test_info = {}
        self.temp_batch = self.search_batch(read_lines)
        test_info["batch name"] = self.temp_batch.name
    
        batch_test = self.temp_batch.search_test(read_lines)
        test_info["test name"] = batch_test["name"]

        if "sub tests" in batch_test:
            sub_test = self.temp_batch.search_sub_test(batch_test["name"], read_lines)
            test_info["sub test name"] = sub_test

        if "SET" in batch_test:
            test_sets = self.temp_batch.search_test_set(batch_test["name"], read_lines)
            test_info["test set"] = test_sets

        if readable:
            return str(list(test_info.values())).replace(", ", "-").replace('[', '').replace(']', '')
        else:
            return test_info


    def get_result_info(self, line:str) -> dict:
        """            
        by a given log line
        in a format like this example: '03/28/2022_13:40:28 4 < 4,85754 < 6 - PASS'
        extracts the limits, measurement and nominal value and returns them
        as a python dictionary
        """
        date_index_separator = 20
        low_limit = ""
        measurement = None
        high_limit = ""
        nominal = None
        result_type = self.get_result_type(line)
        status = self.__get_line_status(line)
        if status != None:
            if result_type == 'numeric':
                meas_info = line[date_index_separator:].split(" - ")[0].replace(" ", "").split("<")
                low_limit = float(meas_info[0].replace(",","."))
                measurement = float(meas_info[1].replace(",","."))
                high_limit = float(meas_info[2].replace(",","."))
                nominal = (float(meas_info[0]) + float(meas_info[2])) / 2
            else:
                pass
                # print(result_type)

            return {
                    "type": result_type,
                    "low limit": low_limit,
                    "measurement": measurement,
                    "high limit": high_limit,
                    "nominal": nominal,
                    "status":status[:4]
                }
        return None

    


    def search_batch(self, passed_lines:list) -> Batch:
        """     
        by a given list of the checked lines, searches in reverse
        for a first occurrence of the batch names, and returns the batch object
        of the batch name occurrence
        """
        for line in reversed(passed_lines):
            batch_names = self.get_batch_names()
            for batch_name in batch_names:
                if batch_name in line:
                    return Batch(batch_name, self.get_batch_info(batch_name))
        return None

    
    def get_batch_names(self) -> list:
        """
        returns a list of strings where every string is
        a batch name (there are only 4 batch names #31/03/2022) 
        """
        batch_names = []
        for batch_dict in self.info:
            batch_names.append(batch_dict["name"])
        return batch_names



    def get_batch_info(self, batch_name:str) -> dict:
        """
        by a given batch name, searches for that input and
        returns the information that the batch should contain
        """
        for batch_info in self.info:
            if batch_info["name"] == batch_name:
                return batch_info


    def write_completed(self) -> bool:
        """
        use this function when the log file is being written,
        and the function will return true when the log file record
        has been completed
        """
        with open(self.path) as log_out_file:
            lines = log_out_file.readlines()
            passed_lines = []
            for line in lines:
                passed_lines.append(line)
                if "End Test" in line:
                    for line in reversed(passed_lines):
                        if self.last_batch_name in line:
                            return True
        return False
    

    def write_stopped(self) -> bool:
        """
        returns true if the log file contains the stop button message
        #in other words, use this function when the log file is being written,
        #and the function will return true if the stop button is pressed
        """
        with open(self.path) as log_file:
            lines = log_file.readlines()
            for line in lines:
                if "Active STOP button" in line:
                    return True
        return False
    
    #returns true if the log file has recorded one or more fails
    def has_fails(self) -> bool:
        with open(self.path) as log_file:
            lines = log_file.readlines()
            for line in lines:
                if 'FAIL' in line:
                    return True
        return False
    
    def get_status(self) -> str:
        if self.write_completed():
            if self.has_fails():
                return 'FAIL'
            else:
                return 'PASS'
        else:
            return 'INCOMPLETE'
        
    
    def __get_line_status(self, line:str) -> str:
        if any(status in line for status in ["PASS", "FAIL"]):
            return line.split(" - ")[-1]
        else:
            return None
    
    def get_result_type(self, line:str) -> str:
        if '<' in line:
            return 'numeric'
        else:
            return 'binary'


    

